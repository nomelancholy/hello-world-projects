# 모두를 위한 컴퓨터 과학

실습은 [CS50 Sandbox](https://sandbox.cs50.io/7bd16f6d-4490-4d9a-81d0-47eaf3c60330)에서 진행했습니다.

## 검색 알고리즘

### 선형 탐색

순차적으로 검색하는 방법. 정렬 여부를 알 수 없을때 택할 수 있는 유일한 방법이지만 효율적이지 않습니다

### 이진 탐색

데이터가 정렬되어 있을 때 사용하는 방법. 순차적으로 정렬되어 있으니 중간 부분을 찾고 그 부분의 값이 찾고자 하는 값보다 큰 지 작은지 확인한 후 크다면 우측을, 작다면 좌측을 확인하는 과정을 원하는 숫자를 찾을 때 까지 반복하는 방법입니다.

## 알고리즘 표기법

알고리즘의 성능은 Big-O 표기법을 활용해 표시할 수 있습니다. n을 데이터의 크기라고 했을 때 이 알고리즘이 최악의 경우 얼만큼의 시간이 걸리는지를 O(n)과 같은 형태로 나타내난 방식입니다. 대표적으론 아래 목록과 같은 Big O 표기가 사용됩니다.

- O(n^2)
- O(n log n)
- O(n)
- O(log n)
- O(1)

이는 시간이 오래 걸리는 (성능이 나쁜) 알고리즘부터 순차적으로 나열한 것입니다. 이 때 상수는 생략합니다.

## 버블 정렬

두 개의 인접한 자료 값을 순차적으로 비교하면서 위치를 정렬하고자 하는 순서대로 교환하는 방식을 총 (n-1)\*(n-2)번 반복하며 정렬하는 방법입니다. 위 반복 횟수를 계산하면 n^2 - 3n + 2가 되는데 Big-O 표기법에선 가장 큰 요소 만을 표기하면 되기 때문에 이 정렬 알고리즘의 성능은 O(n^2)으로 나타낼 수 있습니다. 다만 '교환이 일어나지 않을 때 까지만 정렬하도록' 코딩하고 이미 정렬된 배열이 들어온다고 가정한 가장 좋은 조건에선 n의 성능을 가져 Ω(n) 의 성능을 가진다고 표기할 수 있습니다.

### 버블 정렬의 sudo code

```sudo
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

## 선택 정렬

오름차순으로 정렬하려 한다면 배열을 순서대로 탐색해 가장 작은 수를 찾아 처음 위치로 옮기고, 그 다음 작은 수를 찾아 다음 위치로 옮기고를 모든 정렬이 완료될 때 까지 반복하는 정렬 방식입니다. 이는 n(n+1)/2 만큼의 시간이 걸리기 때문에 Big-O 표기법으로는 버블 정렬과 마찬가지로 O(n^2)의 성능을 가진다고 표기할 수 있습니다. 이는 최선의 경우도 Ω(n^2)의 성능을 가진다고 표기할 수 있습니다. 이렇게 최악의 경우와 최선의 경우가 성능이 같을 때는 Θ(n^2) 과 같이 표기할 수도 있습니다.

### 선택 정렬의 Sudo code

```sudo
For i from 0 to n–1

    Find smallest item between i'th item and last item

    Swap smallest item with i'th item
```

## 재귀

함수가 스스로를 호출하는 것을 재귀(Recursion) 호출이라고 합니다. 재귀 호출을 사용하면 중첩 루프의 사용을 줄이고 코드를 좀 더 직관적이고 효율적으로 설계할 수 있습니다.

## 병합 정렬

원소가 하나가 될 때 까지 데이터를 왼쪽 오른쪽으로 나누고 이를 정렬하며 합쳐나가는 방식으로 정렬하는 알고리즘입니다. 이는 버블 정렬이나 선택 정렬과는 달리 최악의 경우 O(n log n)의 성능을 가집니다. 최선의 경우도 마찬가지로 Ω(n log n)의 성능을 가지기 때문에 병합 정렬의 성능은 Θ(n log n)으로 표기할 수 있습니다.

## 정리

위에서 알아본 검색과 정렬 방식의 실행 시간의 상한과 하한을 정리하면 다음과 같다

실행시간의 상한

O(n^2): 선택 정렬, 버블 정렬
O(n log n): 병합 정렬
O(n): 선형 검색
O(log n): 이진 검색
O(1)

실행시간의 하한

Ω(n^2): 선택 정렬
Ω(n log n): 병합 정렬
Ω(n): 버블 정렬
Ω(log n)
Ω(1): 선형 검색, 이진 검색
