# 정보처리기사 필기

## 소프트웨어 설계

### 소프트웨어 종류 및 개발 방법론

#### 소프트웨어 분류 및 특성 (중)

- 시스템의 기본요소

  - 입력
  - 출력
  - 처리
  - 제어
  - 피드백

- 플랫폼의 개념

  - 많은 응용 프로그램들을 쉽고 편리하게 사용할 수 있도록 지원해주는 하드웨어나 소프트웨어 환경

- 플랫폼의 성능 특성 분석 항목

  - 가용성
  - 응답시간
  - 정확성
  - 사용률

- 소프트웨어 프레임워크의 특징

  - 모듈화
  - 재사용성
  - 확장성
  - 제어의 역 흐름

- 프레임워크 적용시 기대 효과

  - 개발 용이성
  - 품질 보증
  - 변경 용이성
  - 유지보수 용이성
  - 재사용성 향상
  - 표준화율 향상
  - 상호 운용성 향상

- 기업용 소프트웨어

  - 오피스웨어
  - ERP
  - SCM
  - BI
  - CRM

- 컴포넌트

  - 부품화된 프로그램을 모듈, 모듈들의 집합을 라이브러리라고 하고 라이브러리의 집단을 컴포넌트라고 한다. 컴포넌트는 독립적으로 사용될 수 있다.

- CBD(Component Based Development)

  - 재사용이 가능한 컴포넌트 기반의 개발 방법론
  - 개발 기간 단축
  - 유지보수 비용 최소화
  - 시스템 신속 구축 / 새로운 기능 추가 및 확장 용이

- 소프트웨어 공학의 기본원칙

  - 현대적인 프로그래밍 기술을 적용한다.
  - 지속적인 검증을 시행한다.
  - 결과에 관한 명확한 기록을 유지한다.
  - 품질 높은 소프트웨어 상품을 개발한다.

#### 소프트웨어 개발 방법론 (상)

- 운영체제의 종류

  - Windows : 중소규모 서버, 유지 빛 관리 비용 측면에 강점
  - Unix : 대용량 처리, 안정성 우수
  - Linux : 중대규모 서버, 소요 비용 가장 적음
  - iOS : 애플 운영체제
  - Android : 구글의 개방형 운영체제

- 운영체제 분석시 고려사항

  - 신뢰도
  - 성능
  - 기술지원
  - 주변 기기
  - 구축 비용

- CPU

  - CISC (Complex ...)

    - 복잡하고 많은 종류의 명령어와 주소 지정 모드 사용
    - 컴파일 과정이 쉽고 호환성이 좋지만 속도가 느림

  - RISC (Reduced ...)

    - 간단하고 적은 종류의 명령어와 주소 지정 모드 사용
    - 처리 속도가 빠르고 구조가 간단해지지만 효율성과 호환성이 떨어짐

- DBMS 분석시 고려사항

  - 가용성
  - 성능
  - 기술지원
  - 상호 호환성
  - 구축 비용

- 미들웨어의 종류

  - DBMS : 클라이언트와 데이터베이스 연결
  - RPC : 애플리케이션의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저 처럼 호출
  - MOM : 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어. 분산 데이터 시스템의 데이터 동기를 위해 사용
  - TP-Monitor : 트랜잭션 감시
  - ORB : 객체 지향 미들웨어로 CORBA 표준 스펙 구현
  - WAS : 웹 환경 구현을 위한 미들웨어

- WAS의 개념

  - 동적인 웹 서비스의 개발 지원. 접근 관리, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공

- WAS 분석시 고려사항

  - 가용성
  - 성능
  - 기술지원
  - 구축 비용

- 소프트웨어 개발 방법론

  - 구조적 방법론 - 1970년대

    - 절차 : 타당성 검토 -> 계획 -> 요구사항 -> 설계 -> 구현 -> 시험 -> 운용/유지보수
    - 특성 : 정형화 된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 체계적 분석 방법 / 분할과 정복 방법으로, 하향식으로 기능을 분해함, 재사용성, 유지보수성이 낮음

  - 정보공학 방법론 - 1980년대

    - 절차
      - 수직적 구조 방법론 : 정보 전략 계획 -> 업무 영역 분석 -> 업무 시스템 설계 -> 기술 설계 -> 업무 시스템 구축 -> 업무 시스템 실행
      - 수평적 구조 방법론 : 데이터 -> 업무 활동 -> 상호 작용
    - 특징 : 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론 / 데이터 중심 방법론으로 비교적 안정적 / 데이터와 프로세스가 균형적 / 기능별로 유지보수를 해야 하며, 재사용성이 낮다

  - 객체지향 방법론 - 1990년대

    - 절차 : 요구분석 -> 설계 -> 구현 -> 시험 -> 인수
    - 특징 : 객체 지향 기법을 활용하여 시스템을 구축 / 캡슐화, 추상화 기술이 필요, 재사용이 용이

  - 컴포넌트 기반 방법론 - 2000년대

    - 절차 : 개발 준비 -> 분석 -> 설계 -> 구현 -> 시험 -> 전개 -> 인도
    - 특징 : 컴포넌트를 조립해서 하나의 새로운 애플리케이션을 작성하는 방법론 / 생상정과 품질을 높이고 유지보수 비용을 최소화하며 반복적, 점진적으로 개발 / 소프트웨어 위기를 극복하기 위한 방법론

  - 애자일 방법론

    - 등장 배경 : 사용자의 요구사항이 빈번하게 변경됨에 따라 모색
    - 정의 : 요구사항, 설계, 구현, 시험의 단계를 통해 개발하는 방법론
    - 특징 : 프로세스와 도구 중심이 아닌 소통 중심의 개발, 반복적인 개발을 통한 잦은 출시로 제품을 완성해감

  - 애자일 선언문

    - 개인과 상호 작용을 프로세스와 도구보다 중시한다
    - 등장하는 소프트웨어를 포괄적인 문서보다 중시한다.
    - 고객과의 협력을 계약의 협상보다 중시한다.
    - 변화의 대응을 계획의 수행보다 중시한다.

  - 애자일 방법론의 원칙 : 소통 / 협력 / 적응 / 지속 / 가치 전달 / 피드백
  - 애자일 방법론의 5가지 가치

    - 의사소통
    - 용기
    - 피드백
    - 단순함
    - 존경

  - 익스트림 프로그래밍 : 애자일 모형으로 개발하는 대표적인 방법
  - 스크럼 : 애자일 방법론 중의 하나로 프로젝트 관리를 위한 상호 점진적 개발 방법론. 매일 정해진 시간, 장소에서 단기간에 개발

    - 스크럼의 5가지 가치 : 확약 / 전념 / 정직 / 존중 / 용기
    - 스크럼의 요소

      - 백로그 : 프로젝트에 대한 요구사항을 말함
      - 스프린트 : 30일 단위로 분리하여 반복적으로 수행
      - 스크럼 미팅 : 5분 정도의 팀 미팅으로 작업 계획 수립
      - 스크럼 마스터 : 팀 리더로 효율적인 개발과 문제 해결을 위해 노력

  - 린 : 개발 프로세스의 낭비적 부분은 제거하고 개발 결과를 측정, 성과를 분석하여 품질을 향상 시킴

    - 7가지 원칙 : 낭비적 요소를 제거한다 / 품질을 내재화 한다 / 지식을 창출한다 / 가능한 늦게 결정한다 / 가능한 빠르게 인도한다 / 사람을 존중한다 / 전체 공정을 최적화 한다

  - 테일러링 방법론

    - 특징 : 방법론에 표준이 없고 커스터마이징 작업의 반복임.
    - 필요성
      - 내부 기준 : 목표 환경 / 요구 사항 / 포르젝트 규모 / 기술 환경이 다를 경우
      - 외부 기준 : 법적 제약 사항 / 표준 품질 기준이 다를 경우

  - 보안 개발 방법론

    - MS-SDL (Microsoft Secure ...) : MS 자체 수립
    - Seven Touchpoints : 실무적으로 검증된 개발 보안 바법론
    - CLASP (Comprehensive Lightweight Application Security Process) : 소프트웨어 개발 생명주기 초기 단계에서 보안을 강화하기 위한 정형화된 프로세스
    - CWE (Common Weakness Enumeration) : 소프트웨어의 보안 취약점을 유발하는 원인을 7가지로 정리한 방법론

#### 프로젝트 관리 및 생명주기 모형 (상)

- 프로젝트 관리 : 일정 관리, 예산 관리, 인력 관리, 위험 관리, 품질 관리

- 프로젝트 관리의 3P : 사람(People), 문제(Problem), 프로세스(Process)

- 프로젝트 계획 수립 목적 : 범위, 자원, 비용 측정을 통하여 위험성을 최소화 함

  - 소프트웨어 범위 측정 : 처리 기능, 성능, 제한 조건, 개발 인원, 일정 계획
  - 자원 측정
    - 하드웨어 자원: 개발자 시스템, 목표 시스템, 개발 지원 시스템 파악
    - 소프트웨어 자원: 프로그램 작성 도구, CASE 등을 파악
    - 인적 자원 : 개발 조직, 팀 구성, 프로그래머의 능력 파악

- 개발자 팀 구성

  - 책임 프로그래머팀 : 1인 독재 체제. 책임 프로그래머, 보조 프로그래머, 프로그래머, 프로그램 사서로 구성, 소규모 소프트웨어 개발에 유리하나 팀원들 만족도가 낮다. 스타형 구조
  - 민주주의식 팀 : 다수 책임 체제. 개개인의 담당 분야가 독립적으로 존재. 대규모 소프트웨어 개발에 유리하고 팀원들 만족도가 높다. 링형 구조
  - 혼합형 팀 : 책임 프로그래머 팀 + 민주주의식 팀

- PERT (Program-Evaluation and Review Technique) 네트워크

  - 프로그램 평가 및 검토 기술
  - 소요 기간 예측이 어려운 경우에 유리
  - 작업별로 낙관치, 기대치, 비관치를 나누어 종료 시기를 결정
  - 예측치 공식 ((낙관치 + (4 X 기대치) + 비관치) / 6)을 활용해 소요 기간을 정함

- PERT 일정 계획 순서 : 소프트웨어 전체 규모 추정 -> 소프트웨어의 작업을 기능별, 특징별로 분류 -> 단계별로 작업 일정을 예측 -> 전체 소요 기간을 예측

- CPM (Critical Path Method) 네트워크

  - 임계 경로 기법
  - 소요 기간이 확실한 경우에 유리
  - 원형 노드는 작업명, 박스 노드는 이정표와 예상 완료 시간을 표시하고 간선은 작업 사이의 전후 의존 관계를 표시한다.

- CPM을 이용한 일정 계획 순서: 소프트웨어 전체 규모 추정 -> 소프트웨어의 작업을 기능별, 특징별로 분해, 단계별 상호 의존 관계를 CPM 네트워크로 도식화 -> 간트 차트 작성

- 위험 관리 계획 순서 : 위험 식별 -> 위험 분석 및 평가 -> 위험 관리 계획 -> 위험 감시 및 조치

- 비용 측정 요소

  - 직접 측정 요소 : 노력(인월), 비용, 라인 수(LOC), 오류 수, 투입 인원, 처리 속도, 문서 수 등
  - 간접 측정 요소 : 생산성, 품질, 기능 점수(FP), 문서화 비율, 효율성, 신뢰도, 유지보수성 등

- 비용 측정 원칙

  - 소프트웨어의 비용 측정을 최대한 지연 시킨다.
  - 분해 기술을 이용한다
  - 실험적 비용 측정 모델을 이용한다
  - 자동화 도구를 이용한다

- 개발 비용과 개발 기간의 상관 관계 : 개발 비용과 개발 기간의 상관 관계는 반비례 그래프 형태로 표현 가능하다. 즉 개발 기간이 짧아질 수록 개발 비용은 증가하고, 개발 기간이 증가하면 개발 비용은 감소한다.

- 간접 측정 편가 공식

  - 생산성 = LOC / MM
  - 개발 기간 = MM / 개발 인원
  - 개발 비용 = 인월 X 단위 비용

- 비용 측정 방법론의 분류

  - 하향식 : 전체 비용을 측정한 후 기능이나 단계별 비용으로 분리하는 방법 (전문가 측정, 델파이식 측정)
  - 상향식 : 기능이나 단계별로 비용을 측정한 후 전체 비용을 측정하는 방법 (LOC 측정, 단계별 MM, 수학적 산정)
    - 수학적 산정 (Watson 모형, COCOMO 모형, Putnam 모형, 기능 점수 모형, 간이 기능 점수)

- COCOMO 모형

  - 유기형 (Organic) : 기관 내부의 중소 규모 소프트웨어, 과학 기술 계산용, 비즈니스 자료 처리용 소프트웨어 등 5만 라인 이하의 소프트웨어를 평가하는 유형

    ```text
    MM =  2.4 X [KDSI]^1.05
    TDEV(개발 기간) = 2.5 X [MM]^0.38
    ```

  - 준 분리형 (Semi-Detached) : 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등 30만 라인 이하의 소프트웨어를 평가하는 유형

    ```text
    MM =  3.0 X [KDSI]^1.12
    TDEV(개발 기간) = 2.5 X [MM]^0.35
    ```

  - 내재형(Embedded) : 최대형 규모의 트랜잭션 시스템이나 운영체제 등의 소프트웨어을 평가하는 유형

    ```text
    MM =  3.6 X [KDSI]^1.20
    TDEV(개발 기간) = 2.5 X [MM]^0.32
    ```

- Puntam 모형

  - 대형 프로젝트에서 이용되는 기법으로 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도 곡선으로 그려진다. 개발 기간이 연잘될수록 프로젝트 적용 인언의 노력이 감소한다.

  - 총 MM, 개발 기간 등의 비용 측정값을 입력하면 소프트웨어 비용 산출을 자동으로 출력해주는 SLIM은 Putnam 모형을 기초로 해서 만든 자동화 추정 도구이다

  - 모형 공식

    - MM = LOC^3 / [개발 기술 지수]^3 X [개발 기간]^4
    - LOC = [개발 기술 지수] X [MM]^1/3 X [개발 기간]^4/3

- 기능 점수 모형과 LOC 측정 비교

  - 기능 점수 : 전체 생명 주기에 적용, 고객과의 소통 좋음, 고객 관점, 논리적 관점, 국제 표준(ISO/IEC14143)
  - LOC 측정 : 구현 이후 적용, 고객과의 소통 나쁨, 개발자 관점, 물리적 관점, 표준 없음

- 기능 점수 비용 산정 요소

  - 입력 유형의 수
  - 출력 유형의 수
  - 사용자 명령어 수
  - 데이터 파일의 수
  - 인터페이스의 수

- 형상 관리 절차 : 형상 식별 -> 변경 제어 -> 형상 상태 보고 -> 형상 감사

- 형상 관리 항목 : 소프트웨어 공학 기반 표준과 절차, 데이터베이스 기술서, 유지보수 문서

- 소프트웨어 개발의 생명주기 모형

- 폭포수 모형의 개발 순서 : 타당성 검토 -> 계획 단계 -> 요구 분석 -> 설계 단계 -> 구현 단계 -> 검사 단계 -> 운용 + 유지보수

- 프로토타입 모형의 개발 순서 : 요구 수집 -> 빠른 설계 -> 프로토 타입 구축 -> 고객 평가 -> 프로토 타입 조정 or 구현

  - 프로토타입 모형은 요구사항 관리가 중심인 모형이다.

- 브룩스의 이론 : 프로토타입 소프트웨어는 폐기 처분 하는 첫번째 시스템이다. 개발 일정이 지연된다고 해서 말기에 새로운 인원을 투입하면 일정이 더욱 지연된다.

- 나선형 모형의 개발 순서 : 계획 수립 / 위험 분석 / 개발 및 검증 / 고객 평가 단계를 나선형으로 반복하며 개발

  - 나선형 모형은 위험 관리가 중심인 모형이다.

- V 모형의 개발 순서

  ```text
                                            인수 / 설치
  요구 분석 ---    요구 분석 검증     --- 시스템 검사
    시스템 설계 --- 인터페이스 검증 --- 통합 검사
      상세 설계 --- 모듈 검증 --- 단위 검사
                     코딩
  ```

- V 모형의 특징

  - 코딩을 중심으로 각 단계가 V자 모양을 이루고 있음
  - V자 모양 사이의 연결은 각 검사 단계에서 오류가 발생할였을 때 왼쪽의 단계로 되돌아 갈 수 있음을 의미함.
  - 각 개발 단계의 테스트에 중점을 두어 높은 신뢰성을 필요로 하는 시스템 등의 개발에 적합함

- ISO 12207 표준 공정 : 기본 공정, 지원 공정, 조직 공정
- ISO/IEC 품질 특성 : 기능성(Functionality), 신뢰성(Reliability), 사용성(Usability), 효율성(Efficiency), 유지보수성(Maintainability), 이식성(Portability)

  - 이 중 신뢰성만 준수성을 포함하지 않고 있음

- CMM의 5가지 성숙 단계와 핵심 프로세스

  1. 초기 단계(initial) / 없음
  2. 반복 단계(Repeatable) / 요구 관리, 계획, 추적, 감시, 형상 관리, 품질 보증
  3. 정의 단계(Defined) / 조직 프로세스 관리, 교육 훈련 그러그램, 통합 소프트웨어 관리, 생산 공학, 동료 검토, 그룹간 조정, 중간 심사
  4. 관리 단계(Managed) / 정량적 프로세스 관리, 소프트웨어 품질 관리
  5. 최적 단계(Optimizing) / 결함 예방, 기술 변화 관리, 프로세스 변경 관리

- CMM 모델 프로세스 평가 기준

  - Level 1 / 혼돈적 관리 / 순서의 일관성이 없음
  - Level 2 / 경험적 관리 / 일정, 비용의 경험적 법칙 적용
  - Level 3 / 정성적 관리 / 경험 공유, 공식적 프로세스 관리
  - Level 4 / 정량적 관리 / 통계적 방법과 조직적 분석
  - Level 5 / 최적화적 관리 / 위험 예측, 최적화 도구 이용

- SPICE 모델은 소프트웨어 프로세스에 대한 개선 및 능력 측정 기준에 대한 국제 표준으로 개발 기관이 프로세스 개선을 위하여 스스로 평가하는것이다.

- SPICE 모델 프로세스 수행 능력 수준 6단계

  0. 불안정 단계
  1. 수행 단계
  2. 관리 단계
  3. 확립 단계
  4. 예측 단계
  5. 최적화 단계

- CMMI의 프로세스 영역

  - 프로세스 관리 영역
  - 프로젝트 관리 영역
  - 엔지니어링 영역
  - 지원 영역

- CMMI 모델의 종류

  - SW-CMM
  - SECM
  - IPD-CMM
  - People-CMM
  - SA-CMM
  - SECAM

### 요구사항 확인

#### 요구사항 정의 (상)

- 요구사항 개발 프로세스 : 도출 -> 분석 -> 명세 -> 확인

  - 요구사항 도출

    - 소프트웨어가 해결해야 할 문제를 이해하는 첫 번째 단계
    - 요구사항 도출 기법에는 인터뷰, 스토리텔링, 프로토타이핑, 워크숍, 벤치마킹 등이 있다.

  - 요구사항 분석

    - 요구사항의 타당성과 중복을 조사한다.
    - 소프트웨어의 범위와 개발 비용, 일정에 대한 제약을 설정한다.
    - 분석 기법에는 DFD, DD, Mini-Spec, ERD, UML 등이 있다.

    - 구조적 분석의 원리

      - 추상화 원칙 (Principle of Abstract)

      - 정형화 원칙 (Principle of Rormality)

      - 분할 정복 개념 (Divide-and-Conquer Concept)

      - 계층적 구조 개념 (Hierarchical Structure Concept)

    - 구조적 분석 도구

      - 자료흐름도(DFD) : 자료와 정보가 어떻게 흐르고 있는가를 그림으로 도식화

        - 외부 입출력 : 사각형
        - 처리과정 : 타원
        - 자료 흐름 : 화살표
        - 자료 저장소 : 직선 두개

      - 자료 사전(DD : Data Dictionary) : 시스템 관련 자료의 명세와 속성을 파악할 수 있도록 조직화한 도구

        - 자료의 정의 : =
        - 자료의 연결 = +
        - 자료의 선택 = [ | ]
        - 자료의 반복 : { }^n
        - 자료의 생략 : ( )
        - 자료의 설명 : \*\*

      - 소단위 명세서

        - 처리에 영향을 미치는 조건만을 프로그램 설계 언어 (PDL) 로 간단하게 기술하는 명세서

    - 요구사항 분석 과정

      - 요구사항 분류 : 요구중요도, 범위,사용 용이성, 효율성 등에 따라 분류하고 기능적 요구사항과 비기능적 요구사항을 분류한다.

        - 기능적 요구사항 : 시스템에서 제공해야 할 기능을 정의한 것

          - 입력, 출력, 데이터베이스, 통신 기능 등

        - 비기능적 요구사항 : 시스템의 전체적인 품질이나 고려해야 하는 제약사항 등

          - 사용 용이성, 효율성, 신뢰성, 이식성, 유연성, 확장성, 응답 속도, 자원 사용량, 침입 대응, 침입 탐지, 사용자 인증, 권한 부여 등

  - 요구사항 명세

    - 파악한 요구사항을 개발자 뿐만 아니라 고객도 알 수 있도록 쉽게 작성하는 것

    - 정형 명세 기법

      - 사용자의 요구를 수학적인 원리와 표기법을 이용하여 서술

      - 종류 : VDM, Z, CSP, CSS 등

    - 비정형 명세 기법

      - 사용자의 요구를 자연어를 기반으로 서술

      - 종류 : FSM, DEcision Table, E-R, SADT 등

    - 명세서 작성 원칙

      - 명확성
      - 완전성
      - 검증 가능성
      - 일관성
      - 수정 용이성
      - 추적 가능성
      - 개발 후 이용성

  - 요구사항 확인

    - 분석가가 소프트웨어 요구사항을 이해했는지 확인

    - 요구사항 확인 과정

      - 요구사항 검토

      - 프로토 타이핑

      - 모델 검증

      - 인수 테스트

  - 요구사항 검증

    - 요구사항 검토 계획을 수립하고 많은 이해관계자와 함께 다양한 시각에서 공식적으로 검토하고 승인하는 작업

    - 절차

      - 요구사항 검토 계획 수립

      - 요구사항 명세서 검토와 오류 수정

      - 요구사항 베이스라인 설정

    - 방법

      - 요구사항 검토

        - Peer Review : 2~3명 정도의 검토 담당자가 수행하는 검토
        - Walk Through : 소프트웨어 개발 단계마다 실시하는 비정형 검토회의. 오류를 조기에 검출하는 데 목적
        - Inspection : 소프트웨어 개발에 참여하지 않은 다른 전문가에 의해 오류를 찾아내는 공식적 검토 방법
        - 프로토 타입
        - 리팩토링 : 결과의 변경 없이 프로그램 소스의 구조를 재조정하는 것

      - 테스트 설계 : 테스트 케이스를 작성해 요구사항 검증

      - CASE(Computer Aided)

        - 개념 : 소프트 웨어 개발 시점부터 요구 분석, 설계, 개발, 유지보수에 이르기까지 소프트웨어 생명 주기 전반을 지원하는 프로그램 또는 소프트웨어 개발을 지원하는 자동화 도구 혹은 방법론의 결합

        - 분류

          - 상위(Upper) CASE : 요구 분석과 설계 지원
          - 하위(Lower) CASE : 코드 작성 (구현), 검사(테스트) 지원
          - 통합(Total) CASE : 개발 주기 전 과정 지원

        - 4가지 구성 요소

          - 상위부 : 입력
          - 중위부 : 입력 결과 처리
          - 후위부 : 처리 결과 출력
          - 다중 정보 : 데이터베이스

        - 특징

          - 툴의 가격은 비싸지만 소프트웨어 개발 기간이나 인력을 줄일 수 있기 때문에 전체 개발 비용은 절감
          - 생산성, 재사용성이 좋아짐
          - 툴 간 호환성이 없음

        - 요구 분석 자동화 도구(CASE)

          1. SADT : 요구분석과 설계 분석, 설계 명세서를 동시에 표현할 수 있음
          2. BS(Brain Storming)의 4가지 규칙

             - 비판 금지
             - 자유 분방
             - 다수 환영
             - 연쇄 개선

          3. PSL/PSA : PSL이란 기술 언어를 사용하여 작성한 뒤 PSA에 입력하면 최적의 요구 명세서가 자동으로 출력

          4. SREM, RSL/REVS : 도형 표기법 R-Net과 기술용 언어 RSL로 작성된 요구분석의 기본 자료를 REVS에 입력해 RSL에 요구된 사항대로 요구 명세서를 출력

  - 요구 사항의 기술적 타당성 검토

    - 성능 및 용량 산정 적정성 -> 시스템 간 상호 운용성 -> IT 시장 성숙도 및 트렌드 부합성 -> 기술적 위험 분석 (복잡성, 검증 여부, 의존성)

### 애플리케이션 설계

#### 공통 모듈 (중)

- 모듈의 기본 요소

  - 입력 요소
  - 출력 요소
  - 기능 요소
  - 기관 요소
  - 내부 자료 요소

- 모듈의 장점 : 프로그램의 효율적인 관리 가능 / 성능 향상/ 복잡성 감소 / 소프트웨어 시험, 통합, 수정 쉬워짐 / 인터페이스 단순 / 부작용 최소화 /재사용 가능 / 유지보수 용이

- 공유도와 제어도

  - 공유도(Fan-in) : 얼마나 많은 모듈이 해당 모듈을 호출하는가

  - 제어도(Fan-Out) :해당 모듈이 얼마나 많은 모듈을 호출하는 가

- 모듈의 개수 및 비용 상관

  - 모듈의 개수가 많은 수록 노력 비용은 감소하고 통합 비용은 증가
  - 모듈 통합 비용과 개발 비용이 교차되는 ㅜㅂ분의 영역이 최소 노력 비용

- 공통 모듈의 원칙

  - 정확성
  - 명확성
  - 완정성
  - 일관성
  - 추적성

- 공통 모듈 식별 명세

  - 기능을 분석하여 공통 부분 식별
  - 공통 부분에 대한 검토회의

- 공통 모듈의 재사용 범위에 따른 분류

  - 함수와 객체 재사용
  - 컴포넌트 재사용
  - 어플리케이션 재사용

- 소프트웨어 재사용의 이점

  - 개발 시간, 비용 단축
  - 프로젝트 실패 위험 감소
  - 개발 지식 공유
  - 소프트웨어 품질 및 생상성 향상

#### 모듈의 평가 (상)

- 묘듈의 평가 기준

  - 결합도 : 모듈간의 관계썽 척도
  - 응집도 : 한 모듈 내에 있는 처리 요소들 사이의 기능적인 연관 정동
  - 겹합도는 작고 응집도는 클 수록 좋다

- 소프트웨어 모듈 결합도

  - 자료 겹합도 -> 스탬프 결합도 -> 제어 결합도 -> 외부 결합도 -> 공통 결합도 -> 내용 결합도
  - 좌에서 우로 낮은 결합도(높은 품질)에서 높은 결합도(낮은 품질)

  - 자료 결합도 : 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 상호 작용이 일어나는 경우
  - 스탬프 결합도 : 묘듈 간의 인터페이스로 객체나 구조적인 데이터 등이 전달되는 경우
  - 제어 결합도 : 모듈 간에 제어 변수로 종속적인 관계를 갖는 경우. 단순 값만 전달되는 게 아니라 어떻게 ㅎ처리해야 한다는 제어 요소가 전달되는 경우
  - 외부 결합도 : 외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계. 모듈 외부에서 데이터, 프로토콜, 인터페이스 등을 공유할 때 발생
  - 공통 결합도 : 모듈이 다른 모듈의 내부 자료를 참조하는 형태의 결합된 관계
  - 내용 결합도 : 모듈이 다른 모듈의 내부 기능 및 자료를 참조하는 형태의 결합된 관계

- 소프트웨어 모듈 응집도

  - 우연적 응집도 -> 논리적 응집도 -> 시간적 응집도 -> 절차적 응집도 -> 통신적 응집도 -> 순차적 응집도 -> 기능적 응집도
  - 좌에서 우로 낮은 결합도(낮은 품질)에서 높은 결합도(높은 품질)

  - 우연적 응집도 : 모듈 내부의 루틴들이 뚜렷한 관계 없이 묶인 경우
  - 논리적 응집도 : 모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶인 모듈
  - 시간적 응집도 : 모듈 내부의 루틴들이 시간적으로 수행 시기가 같은 기능끼리 묶인 모듈
  - 절차적 응집도 : 모듈 내부의 루틴들이 수행 시기가 순위가 있는 기능끼리 묶인 모듈
  - 통신적 응집도 : 모듈 내부의 루틴들 중 작업 대상이 같은 기능끼리 묶인 모듈
  - 순차적 응집도 : 모듈 내부의 루틴들이 활동으로부터 나온 출력 결과를 그 다음 활동의 입력 자료로 사용하는 경우의 응집도
  - 기능적 응집도 : 모듈 내부가 하나의 단일 기능으로 존재하는 경우로 프로그램 언어에서 지원받는 라이브러리가 모두 이에 속함

## 소프트웨어 개발

### 데이터 입출력 구현

#### 자료 구조 (중)

- 데이터 형태에 따른 자료 구조 분류

  - 단순 구조 : int, float, double, char

  - 선형 구조 : 스택, 큐, 데크, 선형 리스트, 연결 리스트

  - 비선형 구조 : 트리, 그래프

  - 파일 구조

- 배열의 데이터 삽입 / 삭제

  - 삽입 시 데이터 평균 이동횟수 - n+1 / 2
  - 삭제 시 데이터 평균 이동횟수 = n-1 / 2

- 트리 용어

  - 노드 (원)
  - 간선 (노드와 연결된 선)
  - 단말 노드 (자식이 없는 노드)
  - 노드의 차수 (자식 노드의 개수)
  - 트리의 차수 (트리에 있는 노드의 차수 중 가장 큰 값)
  - 노드의 레벨 (특정 깊이를 가지는 노드 집합 - 루트 노드 레벨은 1)

- 그래프 용어

  - 정점 (원)
  - 간선 (선)
  - 완전 그래프 (모든 정점에 간선이 연결된 경우)
  - 부분 그래프 (그래프의 일부분)
  - 경로 (정점과 정점으로 연결된 경로)
  - 경로의 길이 (경로에 존재하는 간선의 수)
  - 사이클 (시작, 종료 정점이 같고 경로의 길이가 2이상)
  - 해밀톤 사이클 (모든 정점을 한번씩 거쳐가는 사이클)
  - 오일러 사이클 (임의 경로에서 모든 간선을 한번씩 사용한 사이클)

- 완전 그래프 간선의 수

  - 무방향성 = n(n-1) / 2
  - 방향성 = n(n-1)

- 이진 트리 순회 방법

  - 중위(in) 순회 : 좌 -> 근 -> 우
  - 전위(pre) 순회 : 근 -> 좌 -> 우
  - 후위(post) 순회 : 좌 -> 우 -> 근

### 애플리케이션 테스트 관리

#### 단위 테스트 (중)

#### 시스템 테스트 (중)

#### 성능 분석 및 품질 평가 (중)

### 인터페이스 구현

#### 인터페이스 설계 명세 (중)

## 데이터베이스 구축

### 데이터 베이스의 개요

#### 데이터 베이스의 종류 (상)

- 데이터 베이스의 종류

  - 파일 시스템
  - HDBMS (Hierachical ...)
    - 데이터를 상하 관계로 계층화하여 관리
    - 접근 속도가 빠르지만 삽입과 삭제에 어려움이 있고 M:N 관계를 직접 표현할 수 없음
  - NDBMS (Network ...)
    - 데이터의 구조를 네트워크 형태로 논리적으로 표현한 데이터 모델
    - 데이터 간의 연계성은 뛰어나지만 설계가 복잡하며 데이터의 종속성 문제를 해결하지 못함
  - RDBMS (Relational)
    - 테이블을 이용하여 데이터 상호 간의 관계를 표현
    - 유지보수성, 생산성, 개발 용이성이 좋지만 시스템 부하가 커서 수행 속도가 느림

- 범용 DBMS

  - RDBMS
    - 오라클, mySql ...
  - 문서 저장 DBMS
    - 일관된 구조가 필요 없지만 클라이언트 단에서 후 처리가 필요함
    - Mongo DB, DynamoDB ...
  - 그래프 DBMS
    - Node와 Edge로 특화되어 있으며 노드 간 관계를 구조화하여 저장한다
    - Neo4j, Orient DB, Arango DB
  - 키 값 DBMS
    - 가장 간단한 형태의 DBMS로 임베디드 시스템과 같은 시스템에 적합
    - Redis, Memcached 

- RDBMS 기본 용어

  - 속성 : 개체 정보의 특성에 대한 이름
  - 도메인 : 한 속성에 입력되는 실제 원자 값들의 범위
  - 튜플 : 속성들에 실제 입력된 값들의 집합(하나의 행)
  - 릴레이션 : 데이터 간에 나타내는 표 자체
  - 차수 : 하나의 릴레이션에서 정의된 속성의 개수(field의 수)
  - 카디날리티 : 하나의릴레이션에 형성된 튜플의 개수(record의 수)

- 릴레이션의 특징

  - 튜플의 유일성
  - 튜플의 무순서
  - 속성의 원자성
  - 속성의 무순서
  - 속성 이름의 유일성

- RDBMS의 키

  - 후보키 : 유일성과 최소성을 만족시키는 모든 키
  - 기본키 : 후보키 중 튜플 구별을 위해 선택된 한 개의 키
  - 대체키 : 후보키 중 기본 키를 제외한 모든 키
  - 외래 키 : 참조하는 키
  - 슈퍼 키 : 튜플을 식별하기 위한 두 개 이상의 속성들의 집합으로 이루어진 키. 유일성은 만족시키지만 최소성은 만족시키지 못한다.

- 무결성 제약 사항

  - 도메인 무결성 : 하나의 속성에 입력되는 값에 대한 정확성을 유지하는 성질
  - 개체 무결성 : 기본키에 NULL을 허용하지 않고 중복된 튜플은 있어서는 안된다는 성질
  - 참조 무결성 : 릴레이션은 참조할 수 없는 외래키를 가질 수 없다는 성질

### 논리 데이터 베이스 설계

#### 관계 스키마와 함수 종속 (상)

- 관계 스키마 이상 현상

  - 삭제 이상 : 임의의 튜플 삭제시 관련된 관계성까지 모두 삭제되는 이상 현상
  - 삽입 이상 : 튜플 삽입시 의도와 관계 없는 관계까지 삽입되는 이상 현상
  - 갱신 이상 : 임의의 데이터 수정시 그것과 관계된 데이터에 대해 일관성이 없게 되는 이상 현상

- 함수 종속 : 개체내 속성간의 종속 관계. A속성의 값으로 B속성의 값을 유일하게 식별할 수 있다면 B속성은 A속성에 함수적으로 종속되었음을 의미

  - 결정자 : A
  - 종속자 : B

#### 데이터베이스의 정규화 (중)

- 정규화 과정

  - 비정규형 - 도메인을 원자값만 갖도록 분해 -> 제 1 정규형
  - 제 1 정규형 - 부분 함수 종속을 제거 -> 제 2 정규형
  - 제 2 정규형 - 이행적 함수 종속을 제거 -> 제 3 정규형
  - 제 3 정규형 - 결정자가 후보키가 아닌 함수 종속을 제거 -> 보이스코드 정규형
  - 보이스코드 정규형 - 다중치 종속을 제거 -> 제 4 정규형
  - 제 4 정규형 - 후보키를 통하지 않은 조인 종속을 제거 -> 제 5 정규형

### SQL

#### SQL 명령어 (상)

#### 병행 제어와 로킹 (중)

### 물리 데이터베이스 설계

#### 분산 데이터베이스 설계 (중)

## 프로그래밍 언어 활용

### 프로그래밍 언어의 활용

#### 알고리즘과 코딩 (중)

- 알고리즘이 갖추어야 할 조건

  - 입력 : 0개 이상
  - 출력 : 1개 이상
  - 명확성
  - 유한성 : 알고리즘은 유한 번 수행 후 종료되더야 함
  - 유효성 : 모든 명령들은 명백하고 실행가능한 연산들이어야 함

- 알고리즘을 분석하는 판단 기준

  - 정확성
  - 간결성
  - 작업량 : 알고리즘을 수행할 때 명령어의 실행 횟수로 평균과 최악의 경우를 나타내는 기준
  - 최적성 : 알고리즘 수행 시간의 평균과 최악이 같을 때 최적이라고 하며 차이가 있는 경우 차이를 계산하여 분석

- 알고리즘 설계 기법

  - 동적 계획법 : Bottom Up
  - 탐욕적 알고리즘
  - 재귀적 알고리즘
  - 근사 알고리즘
  - 배낭 알고리즘
  - 분할 정복법 : Top Down
  - 퇴각 검색법

- 코드의 품질 향상

  - 리팩토링

  - 코드 품질 향상 기법

    - 테스트
    - 코드 인스펙션 : 코드를 눈으로 검사
    - 정적 분석 : 프로그램을 실행시키지 않고 도구를 이용하여 분석
    - 동적 분석 : 프로그램을 실행시키고 도구를 이용하여 분석
    - 증명 : 품질이 아주 중요한 경우 사용

  - 정적 분석 도구 : pmd, cppcheck, SonarQube, Checkstyle
  - 동적 분석 도구 : Avalanche, valgrind

- 클린 코드 작성 원칙

  - 가독성

  - 단순성

  - 의존성 : 영향도 결합도 최소화

  - 중복성

  - 추상화

- C언어 특징

  - 고급 언어 이면서 저급 언어
  - 구조적 프로그래밍 가능
  - 이식성이 뛰어나고 효율적
  - 다양한 연산자를 가지고 있음

### 객체 지향 기술

#### 객체 지향 기술의 개념 (중)

- 객체 지향 기술 특징

  - 현실 세계의 개체를 속성과 메소드가 결합된 형태의 객체로 표현한다

- 객체 지향 기술의 장점

  - 객체를 이용해 쉽게 프로그래밍 할 수 있고 확장성과 유지보수성이 향상된다.

  - 실세계 접근이 가능한 프로그램을 개발할 수 있다.

- 객체 지향 기술의 단점

  - 객체 자체의 설계가 어려우며 실행 속도가 느림

- 객체의 구성 요소

  - 클래스
  - 객체
  - 인스턴스
  - 메시지
  - 캡슐화 : 연관된 속성과 방법을 한 테두리로 묶는 것

    - 캡슐화의 장점

      - 가독성이 좋아 유지보수가 용이
      - 재사용이 용이
      - 중복 최소화
      - 인터페이스 단순화
      - 자료 일관성 유지
      - 변경 발생시 오류 파급 효과 감소

  - 정보 은닉

- 다형성

  - 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질
  - 오버로딩 : 한 메시지가 객체(인수가 다름)에 따라 다른 방법으로 응답할 수 있는 것
  - 오버라이딩 : 상이한 클래스들이 동일한 메소드명을 이용하는 능력 (하위 클래스에서 메소드 재정의)

#### 객체 지향 개발 순서 (상)

- 객체지향 개발 계획

- 객체지향 분석

  - 비즈니스를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해내는 기법

  - 순서

    1. 객체 모델링 : 문제 영역에서 요구되는 객체를 찾아내고 객체의 속성, 연산을 식별
    2. 동적 모델링 : 객체 모델링에서 생성된 객체 모형들의 행위, 상태, 조건 파악 / 사건과 상태를 파악하여 상태도를 만든다 / 상태 다이어그램이 활용된다
    3. 기능 모델링 : 입출력 결정 / 자료 흐름도(DFD) / 기능 내용 기술 / 제약 사항 결정 및 최소화

  - 분석 방법론의 종류

    - Rumbaugh(람바우) Method

      - 객체 지향 분석을 객체 모형 -> 동적 모형 -> 기능 모형 순으로 분석하는 방법

    - E- R 다이어그램

      - 데이터 구조들과 그들 간의 관계를 표현하고 객체 모형을 만드는 방법론
      - 연관 관계를 정의하여 M:N 관계를 표현

    - Booch Method

      - 미시적 개발 프로세스, 거시적 개발 프로세스로 접근하는 방법
      - 각 작업에 대한 다이어그램, 클래스 계층 정의, 클래스들의 클러스터링 작업을 수행

    - Coad와 Yourdon Method

      - E-R 다이어그램을 사용하여 객체의 행위를 모델링함
      - 객체 식별, 구조 식별, 주체 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성

    - Jacobson Method

      - 사용자가 제품 또는 시스템과 어떻게 상호 작용하는지를 서술한 시나리오로 접근

    - Wirfs-Brocks Method

      - 분석과 설계 프로세스 간에 뚜렷한 구분이 없음
      - 고객 명세의 평가로 시작하여 설계로 끝나는 연속적인 프로세스로 접근하는 방법

- 객체지향 설계

  - 특징 : 프로그램으로 실행될 수 있는 문제 영역의 분석 모형을 구체적인 절차로 표현하는 것

  - 원칙

    - 단일 책임 원칙(SRP) : 객체는 하나의 책임만 맡아 처리할 수 있게 해야 함

    - 개방 폐쇄 원칙 (OCP) : 확장에는 열고, 수정 시에는 닫혀 있게 해야 한다.

    - 리스코프 치환의 원칙 (LSP) : 서브 타입은 어디에서나 자신의 기반 타입으로 교체할 수 있어야 한다.

    - 인터페이스 분리의 원칙 (ISP) : 한 개의 일반적인 인터페이스보다 구체적이고 안전한 여러 개의 인터페이스가 좋다. / 클라이언트는 자신이 사용하지 않는 메소드와 의존 관계를 맺으면 안되고 사용하지 않는 인터페이스 때문에 영향을 받아서는 안된다.

    - 의존성 뒤집기의 원칙 (DIP) : 추상화 클래스에 의존하게 되므로 구체적인 클래스에 의존하지 않도록 해야 한다.

- 객체 지향 구현

  - 객체지향 프로그래밍 언어를 선정
  - 클래스를 정의하고 객체를 생성
  - 클래스와 계층 정의
  - 상속과 다형성 활용
  - 메시지를 통하여 객체 간의 상호 작용

- 테스트 및 검증

  - 단위 테스트 : 객체의 가장 작은 단위로 캡슐화 된 클래스나 객체를 검사

  - 통합 테스트

    - 스레드-기반 테스트 : 시스템에 대한 하나의 입력이나 이벤트에 응답하는데 요구되는 클래스들의 집합을 통합함. 객체를 결합한 후 회귀 분석 검사를 실시한다.

    - 사용-기반 테스트 : 상위 클래스와 관계를 갖지 않는 수준에서 클래스들을 독립적으로 검사한 후 상위 클래스와 결합

    - 검증과 시스템 테스트 : 사용자의 요구가 객체에 정확히 반영되었는지, 성능이나 인터페이스 상 오류는 없는지 검사

#### UML 다이어그램 (중)

- UML

  - 객체지향 소프트웨어 개발 과정에서 산출물을 가시성, 명세화, 문서화 할 때 사용되는 모델링 기술 방법론을 통합하여 만든 표준화된 범용 모델링 언어

  - 요구 분석, 설계, 구현 등의 소프트웨어 개발 과정에서 개발자 간의 의사소통을 원활하게 이루어지게 하기 위하여 표준화한 모델링 언어

  - 특징

    - 가시성 : 쉽게 보이는 정도

    - 명세화 : 구현에 필요한 개발적 요소 및 기능에 대한 명세 제공

    - 문서화 : UML로 그려진 소프트웨어 설계 문서는 프로그램의 지식이 없어도 쉽게 알아볼 수 있단

  - 기본 구성 요소

    - 사물

      - 구조 사물

      - 행위 사물

      - 그룹 사물

      - 주석 사물

    - 관계

    - 다이어그램

  - UML 다이어그램의 분류

    - 구조 다이어그램 - 정적 구조

      - 클래스 다이어그램
        - 속성과 함수를 지닌 것들의 범위 및 그룹
        - 접근 제어자 - public = + / pribate = - / protected = # / package = ~
        - 관계 표현
          - 연관 관계 (하나의 클래스가 다른 클레스에 제공하는 기능이 있음을 표시)
            - 실선이나 화살표
          - 일반 관계 (상속 관계에 있을 때 표시 - is kind of)
            - 빈 삼각형 실선
          - 집합 관계 
            - 집약 관계(한 객체가 다른 객체를 포함하는 관계)
              - 빈 마름모 화살표
            - 합성 관계 ( 부분 객체가 전체 객체에 속하는 관계)
              - 채워진 마름모 화살표
          - 의존 관계 (일시적으로 유지하는 관계)
            - 점선 화살표
          - 실체 관계 (인터페이스 관계)
            - 빈 삼각형 점선
      - 객체 다이어그램
        - 클래스의 인스턴스
      - 패키지 다이어그램
        - 객체들의 그룹화 된 표현 / 관련성 있는 객체들을 모아 하나의 패키지로 표시한다
      - 컴포넌트 다이어그램
      - 복합 구조 다이어그램
      - 배치 다이어그램

    - 행위 다이어그램 - 동적 구조

      - 유스케이스 다이어그램
        - 사용자 시각에서 소프트웨어 범위와 기능을 설명하는 설계 표기법
        - 구조적 분석 방법론에서는 자료 흐름도(DFD), 객체지향 분석 방법론에서는 유스케이스 다이어그램을 사용한다.
        - 사용자 ( 사람 모양 ) / 소프트웨어가 사용자에게 제공하기 위한 기능 (타원) / Relationship (연결) 
      - 상태 다이어그램
      - 활동 다이어그램
      - 시퀀스 다이어그램
        - 사용자간의 상호작용을 시간 순서에 따른 메시지 전달로 표현
        - 객체 간에 주고받는 메시지 순서를 시간으 ㅣ흐름에 따라 표현
      - 통신 다이어그램
      - 상호작용 다이어그램
      - 타이밍 다이어그램

  - 분석 모델의 기술적 타당성 검토 순서

    - 성능 및 용량 산정 적정성
    - 시스템 간 상호 운용성
    - IT 시장 성숙도 및 트렌드 부합성
    - 기술적 위험 분석

  - 스테레오 타입

    - UML의 확장 모델. 스테레오 타입 객체를 표현할 때 "<<~>>"를 사용한다

#### 디자인 패턴 (중)

### 운영체제

#### 운영체제의 개념 (상)

- 운영체제 시스템의 성능 평가 척도

  - 처리량 (Throughput) : 동일한 시간 내에서 처리할 수 있는 작업량을 의미
  - 반환 시간 (Turn around time) : 컴퓨터 센터에 작업을 지시하고 결과를 받을 때까지의 경과 시간
  - 신뢰도 (Reliability) : 시스템이 주어진 문제를 얼마나 정확하게 해결하는가를 나타내는 척도
  - 이용 가능도 (availability) : 시스템을 얼마나 빨리 사용할 수 있는가의 정도
  - 병목 현상 (Bottleneck) : 시스템 자원이 용량 또는 처리량에 있어서 최대 한계에 도달할 때 발생

- 운영 체제의 위치

  - 상단에서 하단으로
  - 사용자
  - 응용 프로그램
  - 유틸리티
  - 운영체제
    - 명령어 해석기 (Shell) : 사용자에 의해 명령이 입력되면 명령을 해석하여 제어 프로그램을 동작시키는 프로그램
    - 제어 프로그램 (Kernel) : 컴퓨터의 전반적인 동작을제어할 수 있는 프로그램
    - 기계어 (Machine Language) : 마이크로프로그램을 체계적으로 동작시키기 위한 명령어 형식 (어셈블리어, C언어)
    - 마이크로 프로그램 (Micro Program) : 하드웨어의 기본 동작을 제어하는 마이크로 명령의 조합으로 만들어진 프로그램
  - 하드웨어

#### 프로세스 관리 (중)

- 프로세스 스케쥴링

  - 비선점형 방식 (일단 CPU를 할당 받으면 다른 프로세스가 CPU를 강제적으로 빼앗을 수 없다)

    - FIFO : 입력된 순으로 처리
    - SJF : 실행 시간 추정치가 가장 작은 작업 먼저 실행
    - HRN : 대기시간 + 서비스시간 / 서비스 시간 으로 우선 순위를 계산하여 작업 수행
    - 우선순위
    - 기한부 스케줄링

  - 선점형 방식 (하나의 프로세스가 CPU를 점유하고 있을 때 다른 프로세스가 현재 사용되는 프로세스를 중단시키고 CPU를 차지할 수 있는 방식)

    - 라운드 로빈(RR) : 시간 할당량을 정하고 실행 시간이 이를 초과하면 대기 리스트로 넘기는 방식으로 수행
    - SRT : 작업이 끝나기 까지 남아 있는 실행 시간 추정치가 가장 작은 프로세스를 실행하는 방식
    - MFQ : 짧은 작업이나 입출력 위주의 작업에 우선순위를 부여하기 위해 개발된 방식

  - 교착 상태

    - 복수의 프로세스가 가능하지 못한 상태를 무한정 기다리고 있는 상태

    - 교착 상태 발생 필요 충분 조건

      - 상호배제
      - 비선점
      - 환형 대기
      - 점유와 대기

#### 기억 장치 관리 (중)

## 정보 시스템 구축 관리

### 통신 프로토콜

#### 인터넷 프로토콜 (TCP/IP) (상)

- IPv4 와 IPv6의 차이
  - 주소 길이
    - IPv4 = 32비트
    - IPv6 = 128비트
  - 표시 방법
    - 8비트씩 4부분으로 10진수
    - 16비트씩 8부분으로 16진수

#### 신기술 동향 (중)

### 보안 공격 및 예방

#### 악성 프로그램 (상)

### 암호 기술

#### 정보 추적 기술 (중)
