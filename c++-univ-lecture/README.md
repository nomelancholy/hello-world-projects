# 한국방송통신대학교 C++ 수업 내용 정리

## Hello, World

- 솔루션 : 하나 이상의 프로젝트가 모인 집합
- 프로젝트 : 하나의 프로그램을 만드는 묶음

[소스 보기](./CppPrj/FirstStep/FirstStep.cpp)

## C++ 언어의 소개

### C++ 언어의 개요

- C언어를 객체지향 프로그래밍, 일반화 프로그래밍, 예외처리가 가능하도록 1979년 Bell 연구소에서 만든 프로그래밍 언어
- 89년 표준화 작업에 착수해 98년, 2003년, 2007년 2011년, 2014년, 2017년에 버전 업데이트가 있었다

### C++ 프로그램의 소스 파일

- 소스 프로그램 파일 : 처리하고자 하는 작업을 수행하는 명령어들을 담고 있는 파일. .cpp 확장자를 사용한다.
- 헤더 파일 : 여러 소스 파일에 공통적으로 선언되는 내용을 담고 있는 파일. #include 지시어에 의해 컴파일시 소스 파일에 삽입되어 컴파일 된다. .h 확장자를 사용한다.

### C++ 프로그램의 빌드

- 선행처리기가 #로 지시되는 선행처리기 지시어를 확인해 헤더 파일, 매크로, 등을 소스 파일에 삽입한다. 이 후 컴파일 과정을 거치면 .obj 확장자를 가진 목적 파일이 생성된다. 링커가 이 목적 파일과 필요한 라이브러리를 연결하고 나면 .exe 확장자를 가진 실행 프로그램 파일이 생성된다. 이 전체과정을 '빌드' 과정이라고 한다.

### C++ 프로그래밍 첫걸음

주석, 문장, 함수, 입출력 스트림, 명칭공간

[소스 보기](./CppPrj/NameSpace/NameSpace.cpp)

## 기본 자료형 및 상수와 변수

기본 자료형과 변수, 리터럴, 상수의 선언과 사용, 표현은 다른 프로그래밍 언어와 크게 다르지 않다. 단 constexp 한정어는 조금 특이하다.

### constexpr 한정어

constexpr 한정어가 붙은 변수나 함수는 그 값을 실행중이 아닌 컴파일시 평가한다는 의미이다. 따라서 아래 예제는 주석의 설명과 같이 동작한다.

```C++

int a;
std::cin >> a;
const int b = 20;
const int C1 = a;               // cin을 통해 입력된 a값으로 초기화 가능
constexpr int C2 = a + 10;      // 컴파일 시 a의 값을 알 수 없기 때문에 오류 발생
constexpr int C3 = b + 100;     // b 값은 20으로 고정되어 있기 때문에 컴파일시 알 수 있고 따라서 정상 작동함
constexpr int C$ = C1 * 2;      // a의 값을 컴파일 시에 알 수 없으므로 C1의 값도 컴파일 시 알 수 없다. 오류 발생

```

[예제 소스 보기](./CppPrj/CirclArea/CirclArea.cpp)

### 연산자

연산자 역시 다른 언어들과 비슷하다.

### 자료형의 변환

### 묵시적 형변환

서로 다른 자료형 끼리 형 변환이 필요할 때는 범위가 넓은 자료형으로 묵시적으로 변환된다. 다만 변수에 값을 대입할 때는 값을 받는 변수의 형으로 형 변환이 일어난다.

### 명시적 형변환

명시적 형 변환 방법은 여러가지가 있지만 여기서는 static*cast만 다룬다. 형변환 연산자는 `형변환*연산자<자료형>(수식)` 의 형태로 사용한다. 예제는 아래와 같다.

```c++
int n = 10, m = 3;
float ans = (static_cast<float>(n) / m) * 2; // int 값 끼리의 계산이지만 static_cast를 활용해 n의 값을 float으로 바꿨으므로 n / m, 그리고 * 2 와의 연산 모두 float 형이 반환된다.
```

## 흐름제어 구문

### 조건문

if문, switch 문 / 특이사항 없음

### 반복문

for문, while문, do ... while 문 / 특이사항 없음

## 구조체와 클래스

### 구조체

여러 가지 자료형의 데이터 집합을 저장할 수 있는 새로운 자료형을 정의한 것

```c++

struct StructName {
    Type1 item1;
    Type2 item2;
    ...
}

```

[예제 소스 보기](./CppPrj/Circles1/Circles1.cpp)

### 클래스

표현 대상이 어떤 일을 할 수 있는가 하는 행이와 어떤 데이터를 저장하는가 하는 속성을 하나의 단위로 묶어 선언한 것

[예제 소스 보기](./CppPrj/Circles2/Circles2.cpp)

## 배열, 포인터, 참조

### 배열

```c++
int a[5] = {1, 2, 3, 4, 5};
int arr2D[4][3];

a[4] = 10;

```

위와 같이 선언하고 초기화하고 접근하여 사용

### 포인터

다른 변수, 구조체, 객체 등이 저장된 곳을 가리키는 변수

포인터 선언 형식
`TypeName *ptrVar;`

저장된 곳은 주소 계산 연산자 &을 활용해 알 수 있다.

[예제 소스 보기](./CppPrj/SimplePt/SimplePt.cpp)

#### const 한정어와 포인터

포인터 변수에도 const 한정어를 사용할 수 있다. 다만 사용 위치에 따라 의미가 달라진다. 예를 들어

```c++

int a = 10, b = 20;
const int *ipt = &a;
*ipt = 30; // error
ipt = &b;

```

위와 같은 경우 ipt가 const int에 대한 포인터라는 의미가 되어 ipt가 가리키고 있는 곳의 값을 수정하려는 부분에서 에러가 발생하지만

```c++

int a = 10, b = 20;
int const *ipt = &a;
*ipt = 30;
ipt = &b; // error

```

이 경우는 ipt 자체에 const가 지정되어 ipt의 값을 바꾸려는 부분은 문제 없이 실행되지만 ipt가 가리키는 곳을 바꾸려고 하면 에러가 발생한다.

### 동적 메모리 할당 및 반환

일시적으로 갑자기 많은 메모리를 잡아줘야 하거나, 콜스택 메모리 공간에 영향을 받고 싶지 않거나,크기를 알 수 없는 배열을 저장해야 할 경우 등엔 동적 메모리 할당을 사용하면 유용하다. 이는 new와 delete 키워드를 이용해 공간을 할당받고 반환하는데 이 때 생성된 저장공간은 이름이 없어 이름을 통해 접근할 수 없다. 따라서 이 때 포인터 변수가 유용하게 사용된다.

- 사용 예제 1

```c++

int *intPtr
intPtr = new int;
*intPtr = 10;

delete intPtr;
intPtr = nullptr // 반환된 메모리를 더이상 가리키지 않도록 nullPtr을 입력해준다.
```

- 사용 예제 2 (배열)

```c++

int *intPtr;
intPtr = new int[4];
*intPtr = 10;
*(intPtr + 1) = 20;
intPtr[2] = 30;

delete [] intPtr;
intPtr = nullptr;

```

[예제 소스 보기](./CppPrj/ArrayPtr/ArrayPtr.cpp)

### 참조

참조는 어떠한 대상을 가리킨다는 점에서 포인터와 유사하다. 그러나 초기화 당시 반드시 어떤 대상을 참조해야 하고 초기화를 통해 지정된 참조 대상을 바꿀 수 없다는 점이 다르다. 이런한 참조형 변수는 `TypeName &refVar = varName` 형태로 선언한다.

C++11에서 참조는 l-value 참조와 r-value 참조로 나뉘는데 l-value 참조의 사용 예제는 아래와 같다.

```c++

int a=10, b=20;
int &aRef = a;
cout << aRef << endl;
aRef = 100;
aRef = b

```

## 함수

### 함수의 정의와 호출

다른 프로그래밍 언어와 크게 다르지 않다.

가독성을 위해 함수의 리턴 자료형, 이름, 인자만을 상단에 선언하고 상세 내용은 main 함수 아래에 정의해 주는 방식을 사용한다는 것만이 차이점

### 인수의 전달

C++에서 인수의 전달 방식은 값 호출 방식과 참조 호출 방식으로 나뉜다. 이를 설명하기 위해선 우선 함수를 호출하는 문장에 있는 인수를 실 매개변수, 정의된 함수에 있는 인수를 형식 매개변수라고 부른다는 것을 이해해야 한다.

#### 값 호출

값 호출 방식은 실 매개변수 값이 형식 매개 변수에 복사되는 방식이다. 즉 함수 내부에서 형식 매개 변수를 변경해도 실 매개변수는 변하지 않는다.

#### 참조 호출

참조 호출 방식은 실 매개변수의 참조, 즉 주소를 형식 매개 변수에 전달하는 방식이다. 따라서 형식 매개변수의 값이 변경되면 실 매개변수가 함께 바뀐다.

[예제 소스 보기](./CppPrj/SwapInt/SwapInt.cpp)

#### const 매개 변수

참조 호출 방식은 값을 복사하는 값 호출 방식에 비해 메모리 사용이 적다. 이런 장점은 살리면서도 함수에서 실 매개변수를 변경하는 일은 막고 싶을 때는 const 매개 변수를 활용할 수 있다.

```c++
void PrSalesRec(const SalesRec &srec);
```

#### 디폴트 인수

별도로 입력하지 않으면 함수를 정의할 때 지정한 값이 기본적으로 사용되는 인수. 이 디폴트 인수는 반드시 인수 리스트 중 가장 마지막에 있어야 한다.

ex)

```c++
double Round(double x, int d = 0)
```

### 함수의 다중정의(overloading)

매개 변수의 자료형이나 갯수가 다르다면 같은 이름의 함수를 여러개 정의할 수 있다. 다만 아래와 같은 모호한 함수 다중 정의는 발생하지 않도록 해야 한다.

```c++
int fun(int a)
int fun(int a, b = 100)
```

### inline 함수

함수 선언시 가장 앞에 inline 키워드를 사용하여 선언할 수 있다. 이 키워드가 붙은 함수는 기존 함수 호출 방식처럼 호출되는 것이 아니라 컴파일러가 이렇게 정의된 함수 내 코드 내용을 메인 함수안에 inline으로 삽입한다. 그러나 적절하지 않은 경우엔 inline이 붙어도 컴파일러가 inline 방식으로 처리하지 않기도 한다.

## 클래스와 객체

### 객체

소프트웨어 시스템 안의 어떠한 대상을 행위와 속성으로 표현한 것으로 다른 객체와 상호작용할 수 있음

### 클래스란

객체의 설계도

```c++

class ClassName {
    가시성_지시어_1:    // private(디폴트), public, protected
        데이터 멤버 // 속성
         또는
        멤버함수 리스트; // 행동
    가시성_지시어_1:
        데이터 멤버 // 속성
         또는
        멤버함수 리스트; // 행동
}

```

이 때 멤버 함수에 `int getValue() const {}` 와 같이 const가 붙은 const 멤버 함수는 데이터 멤버의 값을 수정하지 않는 멤버 함수임을 의미한다.

### 캡슐화

객체 내부의 상세한 구현 부분과 외부 사용자의 관점 부분을 분리하는 것. 캡슈화를 하면 유지보수와 재사용이 용이하다.

### 상속

클래스의 계층적 설계

### 생성자

객체가 생성될 때 수행할 자업을 정의하는 특수한 멤버함수

- [예제 소스 (cpp 파일) 보기](./CppPrj/Counter/Counter.cpp)
- [예제 소스 (header 파일) 보기](./CppPrj/Counter/Counter.h)

### 소멸자

객체가 소멸될 때 자동으로 실행되는 함수

- [예제 소스 (main 파일) 보기](./CppPrj/Person/PersonMain.cpp)
- [예제 소스 (cpp 파일) 보기](./CppPrj/Person/Person.cpp)
- [예제 소스 (header 파일) 보기](./CppPrj/Person/Person.h)

## 생성자의 종류

### 디폴트 생성자

어떤 생성자도 생성하지 않으면 컴파일러가 자동으로 만드는 생성자. 다만 어떤 생성자를 생성하면 디폴트 생성자는 생기지 않는다.

### 복사 생성자

같은 클래스의 객체를 복사하여 객체를 만드는 생성자. 인수는 같은 클래스를 참조형으로 받아야 한다. 복사 생성자도 명시적으로 생성하지 않으면 묵시적으로 생성된다.
