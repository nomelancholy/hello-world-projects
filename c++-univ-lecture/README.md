# 한국방송통신대학교 C++ 수업 내용 정리

## Hello, World

- 솔루션 : 하나 이상의 프로젝트가 모인 집합
- 프로젝트 : 하나의 프로그램을 만드는 묶음

[소스 보기](./CppPrj/FirstStep/FirstStep.cpp)

## C++ 언어의 소개

### C++ 언어의 개요

- C언어를 객체지향 프로그래밍, 일반화 프로그래밍, 예외처리가 가능하도록 1979년 Bell 연구소에서 만든 프로그래밍 언어
- 89년 표준화 작업에 착수해 98년, 2003년, 2007년 2011년, 2014년, 2017년에 버전 업데이트가 있었다

### C++ 프로그램의 소스 파일

- 소스 프로그램 파일 : 처리하고자 하는 작업을 수행하는 명령어들을 담고 있는 파일. .cpp 확장자를 사용한다.
- 헤더 파일 : 여러 소스 파일에 공통적으로 선언되는 내용을 담고 있는 파일. #include 지시어에 의해 컴파일시 소스 파일에 삽입되어 컴파일 된다. .h 확장자를 사용한다.

### C++ 프로그램의 빌드

- 선행처리기가 #로 지시되는 선행처리기 지시어를 확인해 헤더 파일, 매크로, 등을 소스 파일에 삽입한다. 이 후 컴파일 과정을 거치면 .obj 확장자를 가진 목적 파일이 생성된다. 링커가 이 목적 파일과 필요한 라이브러리를 연결하고 나면 .exe 확장자를 가진 실행 프로그램 파일이 생성된다. 이 전체과정을 '빌드' 과정이라고 한다.

## 기본 자료형 및 상수와 변수

기본 자료형과 변수, 리터럴, 상수의 선언과 사용, 표현은 다른 프로그래밍 언어와 크게 다르지 않다. 단 constexp 한정어는 조금 특이하다.

### constexpr 한정어

constexpr 한정어가 붙은 변수나 함수는 그 값을 실행중이 아닌 컴파일시 평가한다는 의미이다. 따라서 아래 예제는 주석의 설명과 같이 동작한다.

```C++

int a;
std::cin >> a;
const int b = 20;
const int C1 = a;               // cin을 통해 입력된 a값으로 초기화 가능
constexpr int C2 = a + 10;      // 컴파일 시 a의 값을 알 수 없기 때문에 오류 발생
constexpr int C3 = b + 100;     // b 값은 20으로 고정되어 있기 때문에 컴파일시 알 수 있고 따라서 정상 작동함
constexpr int C$ = C1 * 2;      // a의 값을 컴파일 시에 알 수 없으므로 C1의 값도 컴파일 시 알 수 없다. 오류 발생

```

## 연산자

연산자 역시 다른 언어들과 비슷하다.

## 자료형의 변환

### 묵시적 형변환

서로 다른 자료형 끼리 형 변환이 필요할 때는 범위가 넓은 자료형으로 묵시적으로 변환된다. 다만 변수에 값을 대입할 때는 값을 받는 변수의 형으로 형 변환이 일어난다.

### 명시적 형변환

명시적 형 변환 방법은 여러가지가 있지만 여기서는 static*cast만 다룬다. 형변환 연산자는 `형변환*연산자<자료형>(수식)` 의 형태로 사용한다. 예제는 아래와 같다.

```c++
int n = 10, m = 3;
float ans = (static_cast<float>(n) / m) * 2; // int 값 끼리의 계산이지만 static_cast를 활용해 n의 값을 float으로 바꿨으므로 n / m, 그리고 * 2 와의 연산 모두 float 형이 반환된다.
```
